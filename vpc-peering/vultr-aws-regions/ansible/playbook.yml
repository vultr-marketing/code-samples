---
- name: Wait for all instances to be accessible
  hosts: all
  gather_facts: false
  tasks:
    - name: Wait for SSH to be available
      wait_for:
        host: "{{ ansible_host }}"
        port: 22
        timeout: 300
        delay: 10
        connect_timeout: 5
      register: wait_result
      retries: 30
      delay: 10
      until: wait_result is success
      delegate_to: localhost

- name: Configure Headscale and Tailscale instances
  hosts: all
  gather_facts: true
  tasks:
    - name: Wait for instances to be ready
      wait_for:
        host: "{{ ansible_host }}"
        port: 22
        timeout: 300
      delegate_to: localhost

- name: Generate preauth keys on Headscale
  hosts: headscale_servers
  tasks:
    - name: Create users in Headscale
      shell: |
        set -e
        USERS=$(sudo headscale users list --output json)
        if [ "$USERS" = "null" ] || ! echo "$USERS" | jq -e --arg name "{{ item }}" '.[] | select(.name == $name)' > /dev/null; then
          echo "Creating user {{ item }}"
          sudo headscale users create {{ item }}
        else
          echo "User {{ item }} already exists"
        fi
      loop: "{{ groups['tailscale_servers'] }}"
      register: user_creation

    - name: Wait for users to be created
      pause:
        seconds: 5

    - name: Get user ID for preauth key creation
      shell: |
        set -e
        USER_ID=$(sudo headscale users list --output json | jq -r --arg name "{{ item }}" '.[] | select(.name == $name) | .id')
        if [ -z "$USER_ID" ] || [ "$USER_ID" = "null" ]; then
          echo "User {{ item }} not found"
          exit 1
        fi
        echo $USER_ID
      loop: "{{ groups['tailscale_servers'] }}"
      register: user_ids

    - name: Create preauth keys for each region
      shell: |
        set -e
        echo "Creating preauth key for {{ item.0 }} (ID: {{ item.1.stdout }})"
        sudo headscale preauthkeys create --user {{ item.1.stdout }} --reusable --expiration 24h --output json > /tmp/{{ item.0 }}_authkey.json
        if [ ! -s /tmp/{{ item.0 }}_authkey.json ]; then
          echo 'Failed to generate preauth key'
          exit 1
        fi
      loop: "{{ groups['tailscale_servers'] | zip(user_ids.results) | list }}"
      register: key_creation

    - name: Verify preauth keys exist
      shell: |
        set -e
        if [ ! -f "/tmp/{{ item }}_authkey.json" ]; then
          echo "Preauth key file for {{ item }} does not exist"
          exit 1
        fi
      loop: "{{ groups['tailscale_servers'] }}"
      register: key_verify
      failed_when: key_verify.rc != 0

- name: Configure Tailscale instances
  hosts: tailscale_servers
  tasks:
    - name: Check if Tailscale is inactive
      shell: |
        if sudo tailscale status | grep -q "Logged out"; then
          echo "needs_configuration"
        else
          echo "already_configured"
        fi
      register: tailscale_status
      changed_when: false

    - name: Get preauth key from headscale server
      shell: sudo cat /tmp/{{ inventory_hostname }}_authkey.json | jq -r .key
      register: auth_key
      delegate_to: headscale
      failed_when: auth_key.stdout == ""
      when: tailscale_status.stdout == "needs_configuration"

    - name: Get subnet information
      shell: |
        set -e
        DEFAULT_IFACE=$(ip route | grep default | awk '{print $5}' | head -1)
        PRIVATE_SUBNET=$(ip route | grep 'proto kernel scope link' | grep -E '^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)' | grep -v "$DEFAULT_IFACE" | awk '{print $1}' | head -1)
        
        if [ -n "$PRIVATE_SUBNET" ]; then
          SUBNET="$PRIVATE_SUBNET"
        else
          PRIVATE_SUBNET=$(ip route | grep 'proto kernel scope link' | grep -E '^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)' | awk '{print $1}' | head -1)
          if [ -n "$PRIVATE_SUBNET" ]; then
            SUBNET="$PRIVATE_SUBNET"
          else
            SUBNET=$(ip route | grep $DEFAULT_IFACE | grep -v default | grep -v via | awk '{print $1}' | head -1)
          fi
        fi
        
        if [ -z "$SUBNET" ]; then
          echo 'Failed to get subnet'
          exit 1
        fi
        echo $SUBNET
      register: subnet_info
      failed_when: subnet_info.stdout == ""
      when: tailscale_status.stdout == "needs_configuration"

    - name: Start Tailscale
      shell: |
        set -e
        sudo tailscale up --login-server http://{{ hostvars['headscale']['ansible_host'] }}:8080 \
          --authkey {{ auth_key.stdout }} \
          --accept-routes \
          --advertise-routes {{ subnet_info.stdout }} \
          --hostname {{ inventory_hostname }}
      register: tailscale_up
      when: tailscale_status.stdout == "needs_configuration"

    - name: Wait for Tailscale to be ready
      wait_for:
        host: "{{ ansible_host }}"
        port: 22
        timeout: 60
      when: tailscale_up.changed

    - name: Restart FRR if Tailscale was started
      shell: |
        set -e
        sudo systemctl stop frr || true
        sleep 5
        sudo systemctl start frr
        sleep 5
        sudo systemctl status frr
      when: tailscale_up.changed
      register: frr_restart
      retries: 3
      delay: 10
      until: frr_restart.rc == 0

    - name: Ensure Tailscale hostname matches inventory
      shell: sudo tailscale set --hostname {{ inventory_hostname }}
      register: ts_set_host
      changed_when: ts_set_host.rc == 0
      failed_when: false

- name: Configure routing on Headscale
  hosts: headscale_servers
  tasks:
    - name: Enable all routes
      shell: |
        set -e
        echo "Getting all nodes with available routes..."
        NODES=$(sudo headscale nodes list --output json)
        
        if [ -n "$NODES" ] && [ "$NODES" != "null" ]; then
          # Get nodes that have available_routes
          echo "$NODES" | jq -r '.[] | select(.available_routes != null and (.available_routes | length > 0)) | "\(.id) \(.name) \(.available_routes | join(" "))"' | while read -r node_id node_name routes; do
            echo "Processing node $node_id ($node_name) with routes: $routes"
            
            # Approve each route for this node
            for route in $routes; do
              echo "Approving route $route for node $node_id"
              sudo headscale nodes approve-routes -i "$node_id" -r "$route" || echo "Failed to approve route $route for node $node_id"
            done
          done
        fi
        
        echo "Final route status:"
        sudo headscale nodes list-routes
      register: route_enable
      changed_when: route_enable.stdout != ""

- name: Update main routing table
  hosts: tailscale_servers
  tasks:
    - name: Add routes to main table
      shell: |
        set -e
        sudo ip route show table 52 | while read -r ROUTE; do
          if [ -n "$ROUTE" ]; then
            sudo ip route replace $ROUTE
          fi
        done
      register: route_update

