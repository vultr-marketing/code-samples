---
- name: Wait for all instances to be accessible
  hosts: all
  gather_facts: false
  tasks:
    - name: Wait for SSH to be available
      wait_for:
        host: "{{ ansible_host }}"
        port: 22
        timeout: 300
        delay: 10
        connect_timeout: 5
      register: wait_result
      retries: 30
      delay: 10
      until: wait_result is success
      delegate_to: localhost

- name: Configure Headscale and Tailscale instances
  hosts: all
  gather_facts: true
  tasks:
    - name: Check if cloud-init exists
      shell: command -v cloud-init >/dev/null 2>&1
      register: ci
      changed_when: false
      failed_when: false

    - name: Wait for cloud-init to finish
      shell: cloud-init status --wait || true
      changed_when: false
      when: ci.rc == 0
    - name: Wait for instances to be ready
      wait_for:
        host: "{{ ansible_host }}"
        port: 22
        timeout: 300
      delegate_to: localhost

- name: Generate preauth keys on Headscale
  hosts: headscale_servers
  tasks:
    - name: Create users in Headscale
      shell: |
        set -e
        USERS=$(sudo headscale users list --output json)
        if [ "$USERS" = "null" ] || ! echo "$USERS" | jq -e --arg name "{{ item }}" '.[] | select(.name == $name)' > /dev/null; then
          echo "Creating user {{ item }}"
          sudo headscale users create {{ item }}
        else
          echo "User {{ item }} already exists"
        fi
      loop: "{{ groups['tailscale_servers'] }}"
      register: user_creation

    - name: Wait for users to be created
      pause:
        seconds: 5

    - name: Get user ID for preauth key creation
      shell: |
        set -e
        USER_ID=$(sudo headscale users list --output json | jq -r --arg name "{{ item }}" '.[] | select(.name == $name) | .id')
        if [ -z "$USER_ID" ] || [ "$USER_ID" = "null" ]; then
          echo "User {{ item }} not found"
          exit 1
        fi
        echo $USER_ID
      loop: "{{ groups['tailscale_servers'] }}"
      register: user_ids

    - name: Create preauth keys for each region
      shell: |
        set -e
        echo "Creating preauth key for {{ item.0 }} (ID: {{ item.1.stdout }})"
        sudo headscale preauthkeys create --user {{ item.1.stdout }} --reusable --expiration 24h --output json > /tmp/{{ item.0 }}_authkey.json
        if [ ! -s /tmp/{{ item.0 }}_authkey.json ]; then
          echo 'Failed to generate preauth key'
          exit 1
        fi
      loop: "{{ groups['tailscale_servers'] | zip(user_ids.results) | list }}"
      register: key_creation

    - name: Verify preauth keys exist
      shell: |
        set -e
        if [ ! -f "/tmp/{{ item }}_authkey.json" ]; then
          echo "Preauth key file for {{ item }} does not exist"
          exit 1
        fi
      loop: "{{ groups['tailscale_servers'] }}"
      register: key_verify
      failed_when: key_verify.rc != 0

- name: Configure Tailscale instances
  hosts: tailscale_servers
  tasks:
    - name: Ensure Tailscale is installed
      become: true
      shell: |
        set -e
        if ! command -v tailscale >/dev/null 2>&1; then
          apt-get update -y
          apt-get install -y curl
          curl -fsSL https://tailscale.com/install.sh | sh
        fi
      register: tailscale_install
      changed_when: false
      failed_when: false
    - name: Enable and persist IP forwarding (IPv4/IPv6)
      become: true
      shell: |
        set -e
        printf "net.ipv4.ip_forward = 1\nnet.ipv6.conf.all.forwarding = 1\n" >/etc/sysctl.d/99-forwarding.conf
        sysctl -w net.ipv4.ip_forward=1
        sysctl -w net.ipv6.conf.all.forwarding=1
        sysctl --system >/dev/null 2>&1 || true
      register: ipfwd
      changed_when: false
      failed_when: false
    - name: Check if Tailscale is inactive
      shell: |
        set -e
        if sudo tailscale status >/dev/null 2>&1; then
          if sudo tailscale status | grep -q "Logged out"; then
            echo "needs_configuration"
          else
            echo "already_configured"
          fi
        else
          echo "needs_configuration"
        fi
      register: tailscale_status
      changed_when: false

    - name: Get preauth key from headscale server
      shell: sudo cat /tmp/{{ inventory_hostname }}_authkey.json | jq -r .key
      register: auth_key
      delegate_to: headscale
      failed_when: auth_key.stdout == ""
      when: tailscale_status.stdout == "needs_configuration"

    - name: Prefer inventory-provided subnet CIDR
      set_fact:
        advertise_cidr: "{{ hostvars[inventory_hostname].subnet | default('') }}"
      when: tailscale_status.stdout == "needs_configuration" or tailscale_status.stdout == "already_configured"

    - name: Detect subnet CIDR from OS
      shell: |
        set -e
        DEV=$(ip route | awk '/^default/{print $5; exit}')
        CIDR=$(ip -j route list dev "$DEV" | jq -r '[.[] | select(.dst | test("/")) | select((.protocol // "") == "kernel" or (.protocol // "") == "boot") | select((.scope // "") == "link")][0].dst // empty')
        if [ -z "$CIDR" ]; then
          CIDR=$(ip -o -f inet addr show dev "$DEV" | awk '{print $4}' | head -1)
        fi
        if [ -z "$CIDR" ] || ! echo "$CIDR" | grep -q '/'; then
          echo 'Failed to get CIDR'
          exit 1
        fi
        echo "$CIDR"
      register: subnet_info
      when: (tailscale_status.stdout == "needs_configuration" or tailscale_status.stdout == "already_configured") and (advertise_cidr is not defined or advertise_cidr == '')
      changed_when: false

    - name: Resolve advertise CIDR value
      set_fact:
        advertise_cidr: "{{ advertise_cidr | default(subnet_info.stdout) }}"
      when: tailscale_status.stdout == "needs_configuration" or tailscale_status.stdout == "already_configured"

    - name: Start Tailscale
      shell: |
        set -e
        sudo tailscale up --login-server http://{{ hostvars['headscale']['ansible_host'] }}:8080 \
          --authkey {{ auth_key.stdout }} \
          --accept-routes \
          --advertise-routes {{ advertise_cidr }} \
          --hostname {{ inventory_hostname }}
      register: tailscale_up
      when: tailscale_status.stdout == "needs_configuration" and (auth_key is defined)

    - name: Update Tailscale advertised routes
      shell: |
        set -e
        sudo tailscale set --advertise-routes {{ advertise_cidr }}
      register: ts_set_routes
      changed_when: ts_set_routes.rc == 0
      failed_when: false
      when: tailscale_status.stdout == "already_configured"

    - name: Wait for Tailscale to be ready
      wait_for:
        host: "{{ ansible_host }}"
        port: 22
        timeout: 60
      when: (tailscale_up is defined and tailscale_up.changed) or (ts_set_routes is defined and ts_set_routes.changed)

    - name: Gather service facts
      service_facts:
      when: (tailscale_up is defined and tailscale_up.changed) or (ts_set_routes is defined and ts_set_routes.changed)

    - name: Restart FRR if Tailscale was started and FRR present
      shell: |
        set -e
        sudo systemctl stop frr || true
        sleep 5
        sudo systemctl start frr
        sleep 5
        sudo systemctl status frr
      when: ('frr.service' in ansible_facts.services) and ((tailscale_up is defined and tailscale_up.changed) or (ts_set_routes is defined and ts_set_routes.changed))
      register: frr_restart
      retries: 3
      delay: 10
      until: frr_restart.rc == 0

    - name: Ensure Tailscale hostname matches inventory
      shell: sudo tailscale set --hostname {{ inventory_hostname }}
      register: ts_set_host
      changed_when: ts_set_host.rc == 0
      failed_when: false

    - name: Determine OVH peer private IP
      when: inventory_hostname.startswith('ovh-peer-')
      shell: |
        set -e
        DEV=$(ip route | awk '/^default/{print $5; exit}')
        ip -o -f inet addr show dev "$DEV" | awk 'NR==1{print $4}' | cut -d/ -f1
      register: ovh_peer_priv
      changed_when: false

    - name: Collect all advertised subnets from inventory
      when: inventory_hostname.startswith('ovh-peer-')
      set_fact:
        all_advertised_subnets: "{{ (all_advertised_subnets | default([])) + ([ hostvars[item].subnet ] if hostvars[item].subnet is defined else []) }}"
      loop: "{{ groups['tailscale_servers'] | default([]) }}"
      changed_when: false

    - name: Compute destination subnets
      when: inventory_hostname.startswith('ovh-peer-')
      set_fact:
        dest_subnets: "{{ all_advertised_subnets | default([]) | unique | difference([ hostvars[inventory_hostname].subnet ]) }}"
      changed_when: false

- name: Configure routing on Headscale
  hosts: headscale_servers
  tasks:
    - name: Auto-approve all advertised routes
      become: true
      shell: |
        set -e
        HS_BIN="headscale"
        command -v "$HS_BIN" >/dev/null 2>&1 || HS_BIN="/usr/bin/headscale"

        ROUTE_IDS=$($HS_BIN nodes list-routes --output json 2>/dev/null | jq -r '.[] | select((.approved // false) == false) | .id' || true)
        if [ -n "$ROUTE_IDS" ]; then
          for rid in $ROUTE_IDS; do
            $HS_BIN nodes approve-routes --route-id "$rid" || true
          done
        fi

        NODES_JSON=$($HS_BIN nodes list --output json 2>/dev/null || echo '[]')
        echo "$NODES_JSON" | jq -r '.[] | select(.available_routes != null and (.available_routes | length > 0)) | @base64' | while read row; do
          node_id=$(echo "$row" | base64 -d | jq -r '.id')
          echo "$row" | base64 -d | jq -r '.available_routes[]' | while read route; do
            $HS_BIN nodes approve-routes -i "$node_id" -r "$route" || true
          done
        done

        $HS_BIN nodes list-routes || true
      register: auto_approve_routes
      changed_when: auto_approve_routes.stdout is search('Approved|Serving|route')

- name: Update main routing table
  hosts: tailscale_servers
  tasks:
    - name: Add routes to main table
      shell: |
        set -e
        DEV=$(ip route | awk '/^default/{print $5; exit}')
        LOCAL_CIDR=$(ip -o route list dev "$DEV" proto kernel scope link | awk 'NR==1{print $1}')
        sudo ip route show table 52 | while read -r ROUTE; do
          [ -n "$ROUTE" ] || continue
          DST=$(echo "$ROUTE" | awk '{print $1}')
          if [ "$DST" = "$LOCAL_CIDR" ]; then
            continue
          fi
          sudo ip route replace $ROUTE
        done
      register: route_update

- name: Configure OSPF on clients using mesh-init
  hosts: client_servers
  tasks:
    - name: Run mesh-init on clients
      become: true
      script: ../scripts/mesh-init.sh

- name: Finalize route sync after approvals and client OSPF
  hosts: tailscale_servers
  tasks:
    - name: Resync Tailscale routes into main table
      shell: |
        set -e
        DEV=$(ip route | awk '/^default/{print $5; exit}')
        LOCAL_CIDR=$(ip -o route list dev "$DEV" proto kernel scope link | awk 'NR==1{print $1}')
        for i in $(seq 1 12); do
          if ip route show table 52 | grep -q "/"; then break; fi
          sleep 5
        done
        sudo ip route show table 52 | while read -r ROUTE; do
          [ -n "$ROUTE" ] || continue
          DST=$(echo "$ROUTE" | awk '{print $1}')
          if [ "$DST" = "$LOCAL_CIDR" ]; then
            continue
          fi
          sudo ip route replace $ROUTE
        done
      register: route_update_final

    - name: Verify OVH routes exist and are resolvable
      shell: |
        set -e
        OK=1
        for cidr in {{ groups['tailscale_servers'] | default([]) | select('match','^ovh-peer-') | list | map('extract', hostvars) | map(attribute='subnet') | list | unique | join(' ') }}; do
          if ! ip route show table 52 | awk '{print $1}' | grep -qx "$cidr"; then
            OK=0
            break
          fi
          ip=$(echo "$cidr" | awk -F/ '{print $1}' | awk -F. '{print $1"."$2"."$3".1"}')
          if ! ip route get "$ip" >/dev/null 2>&1; then
            OK=0
            break
          fi
        done
        if [ "$OK" -ne 1 ]; then
          exit 1
        fi
      register: ovh_route_verify
      retries: 12
      delay: 5
      until: ovh_route_verify.rc == 0
      when: inventory_hostname.startswith('vultr-peer-')
